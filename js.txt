（1）getComputedStyle与currentStyle

http://www.zhangxinxu.com/wordpress/2012/05/getcomputedstyle-js-getpropertyvalue-currentstyle/







 (2)  原生 JS 获取元素的尺寸和位置 

https://segmentfault.com/a/1190000007687940






（3）array reduce

数值型数组的累加
[1, 2, 3].reduce((sum, el) => sum + el, 0)
或 （没有默认值时sum的值为数组的第一个元素，所以参与循环的是arr[1:], 比定义默认值时少一个迭代）
[1, 2, 3].reduce((sum, el) => sum + el)；

对象型数组的累加
[{num: 1, ind: 2}, {num: 1, ind: 2}, {num: 1, ind: 2}].reduce((sum, el) => {sum.num = sum.num + el.num;sum.ind = sum.ind + el.ind; return sum}, {num: 0, ind: 0})
或 （没有默认值时sum的值为数组的第一个元素，所以参与循环的是arr[1:], 比定义默认值时少一个迭代）
[{num: 1, ind: 2}, {num: 1, ind: 2}, {num: 1, ind: 2}].reduce((sum, el) => {sum.num = sum.num + el.num;sum.ind = sum.ind + el.ind; return sum})





（4）promise 串行请求（可改造成可以控制并发数的串行请求）

    layerDef._loadDisposable = this.backendService.getData('./assets/datas/fi/airport.json').map(res => res.json()).mergeMap((res: any) => {
      let promiseQueue:any = Promise.resolve(null);
      res.features.forEach((element, index) => {
        promiseQueue = promiseQueue.then((data) => {  //then方法会返回新的promise,所以需要存储最新的
          if (data && data.data) {
            dataRender(data.data);
          }

          if (!this.amdarCancel) {  //由于rxjs不知道为什么这里订阅取消不掉，才采用这种不妥的方式来取消订阅
            return this.backendService.getData(url+ '&airport=' + element.properties.name).map(res => res.json()).toPromise();
          }

          return null;
        })
      });
      promiseQueue.catch((err) => console.error(err));

      return promiseQueue;
    }).subscribe(
      (data: any) => {
        this.missionService.addloading(false);
      },
      err => {
        this.missionService.addloading(false);
      }
    );





（5）使用js导出csv文件
https://halistechnology.com/2015/05/28/use-javascript-to-export-your-data-as-csv/






（6）页面滚动

var toTop = document.documentElement.scrollHeight;


var timer = setInterval(function (){
	if(toTop<0) {clearInterval(timer)}
	document.documentElement.scrollTo(0, toTop-=10);
},5);



https://blog.csdn.net/github_39598787/article/details/80310997

https://blog.csdn.net/white__cat/article/details/55188948

https://blog.csdn.net/houyanhua1/article/details/79579714

https://blog.csdn.net/L25000/article/details/46343665

https://blog.csdn.net/zhq426/article/details/5755825






（7）offsetTop










（8）js判断是否是数字

    // 判断一个字符串是否为数字
    isNumber(str: string) {
        // [+-]?  匹配一个加或一个减或不匹配
        //(0|[1-9][0-9]*)  只匹配一个0 或 匹配以非零开始的整数
        //(\.[0-9]+)?  /要么不匹配要么匹配一个.并且后面跟有数字
        return /^[+-]?(0|[1-9][0-9]*)(\.[0-9]+)?$/.test(str);
    }

    // 强化isNaN函数,以判断是否为非数字
    isNaN(val: any) {
        // /^\s*$/ 匹配空字符
        if (/^\s*$/.test(val) || val === null) return true;
        return isNaN(val);
    }





（9）巧用 || 逻辑运算符

  var name = obj.name;  //假定obj对象下的name属性不一定存在，但是我想保正如果不存在时name值为空字符串;

例1：name = name || '';
例2:  name = name ? name : '';

想要的输出：var domStr = '<img src="./xxx.png" title="'+ name +'">';

由上可见例1比例2更简单






（10）万能排序（数字，字母， 中文）

const sort = (arr, isUpSort) => {
        return arr.slice().sort((a, b) => {
          if (isUpSort) {
            return b.localeCompare(a);
          }else {
            return a.localeCompare(b);
          }
        })
};



（11）document.domain 和 window.postMessage 跨域 ：https://www.cnblogs.com/webbest/p/7161174.html

document.domain必须主域相同 而 window.postMessage没有限制







（12）简单的事件节流 与 防抖

            // 事件节流
            let isCanRun = true;
            window.addEventListener('resize', function () {
                if (!isCanRun) return
                isCanRun = false
                setTimeout(function () {
                    console.log('事件节流')  //你的代码逻辑
                    isCanRun = true
                }, 300)
            })

            // 事件防抖
            let timer = null;
            document.getElementById('#input').addEventListener('input', function () {
                clearTimeout(timer)
                timer = setTimeout(function () {
                    console.log('事件防抖')  //你的代码逻辑
                }, 300)
            })



















