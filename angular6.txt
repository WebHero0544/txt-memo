（1）针对@angular/cli@6.0.8

在启动服务时，即ng serve,如果出现95% emitting LicenseWebpackPlugin的问题的解决办法：

删除node-modules,再用npm install 安装，不要使用cnpm




（2）我用@angular/cli@6.0.8创建一个angular6项目使用的命令：ng new appName --routing --style scss





（3）请求文件（xml | html ....）的配置：this.http.get('文件路径', {responseType: 'text'});





（4）操作dom的方式：@ViewChild('模板引用变量名称')，ElementRef， Renderer2

@ViewChild : https://segmentfault.com/a/1190000008695459




（5）对于请求文件
this.http.get( '文件路径', { responseType: 'text' })






（6）NgTemplateOutlet










（6）ng-template详解：https://toddmotto.com/angular-ngfor-template-element






（7）一个属性可以同时使用多个属性装饰器（下面的代码来自于组件）

  // dbsChecked 同时用了两个属性装饰器，表示当输入属性的值为true时，在组件的宿主元素上加上名为active的class样式，当false时，则去掉名为active的class样式
  @Input()
  @HostBinding('class.active') dbsChecked: boolean = false;







（8）[ngStyle]="{'background-image': 'url('+ dbsRightTop +')'}"    这样绑定可以避免出现安全性的警告







（9）async函数的简单使用方式以及需要注意的事项：
export class DropForecastService {

  constructor(
    public http: HttpClient,
  ) {
    this.asyncFn()
    .then(function (data) {
      console.log(data);
    })
    .catch(function (err) {
      console.error(err);
    })
  }

  // async函数中 当await后面的promise返回结果时才会继续执行后面的代码，捕获错误时要用throw抛出异常，不然catch不会被调用
  async asyncFn () {
    try {
      const f1: any = await this.http.get('./assets/demo.json').toPromise();
      const f2: any = await this.http.get('./assets/demo.json', {params: f1}).toPromise();
      return this.http.get('./assets/demo.json', {params: f2}).toPromise();
    } catch (error) {
      // new Error(error);  //这样任然会调用then,而catch不会被调用
      throw new Error(error);
    }

  };

}







（10）当<div [@flyInOut]="'in'"></div>*通配符会自动匹配到当前激活的名为in的状态

animations: [
  trigger('flyInOut', [
    state('in', style({opacity: 1, transform: 'translateX(0)'})),
    transition('void => *', [
      style({
        opacity: 0,
        transform: 'translateX(-100%)'
      }),
      animate('0.2s ease-in')
    ]),
    transition('* => void', [
      animate('0.2s 0.1s ease-out', style({
        opacity: 0,
        transform: 'translateX(100%)'
      }))
    ])
  ])
]




（11）ContentChild    $implicit






（12）在angular项目中我已使用了路由模块，即是异步加载的模块，但也可以一个模块导出(export)一个对外暴露的组件，然后在根路由中配置该模块的路由，即是同步加载的模块，同步与异步模块的使用要根据项目的大小和运行终端予以取舍














